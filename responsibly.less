/**
 * Grid requirements
 *
 * 1. Grid must be fluid so it adjusts on every viewport's content width
 * 2. Grid must be able to float items on multiple lines, e.g. 4 items on one or 2 lines (2 items each)
 * 3. Grid should be applicable as HTML classes and/or mixins
 * 4. You should be able to set up responsive grid layouts
 *    e.g. different amount of columns in different viewports (see requirement 2)
 * 
 * 
 * Grid specs
 * 
 * 1. We use percentage widths and spacings to cover requirement 1
 * 2. We use a negative margin row with all left margin cols to cover requirement 2
 * 3. The grid can be set up completely in HTML by using the given classes: .row, .layout-responsive-x, .col, .col-span-xx, .offset-x
 *    Or you can apply the same styles in LESS by using the mixins: .row(), .layout-responsive-x(), .col(), .col-span(xx), .offset(x)
 * 4. To build a responsive grid use .layout-responsive classes on your grid .rows and declare the .cols inside those layouts.
 *    Use .col-xx instead of .col-span-xx as logical unit inside such a layout if columns have different sizes
 * 
 * NEW
 * Use .ordered, .pull-x and .push-x to optically reposition elements while keeping the html order!
 * credit for this goes to twitter bootstrap
 *
 *
 * Hint: since everything gets calculated within mixins you could even use float numbers for grid widths ;)
 * .col-span(3.5)
 **/

/*--- base variables ---*/
@grid-fixed-width: 960px;
@grid-fixed-gutter: 20px;
@grid-max-cols: 12;
// grid type either fluid or fixed
@grid-type: 'fluid';
// to what floating point number should be rounded?
@decimal-places: 3;

/*
 * duplicate mixin switches according to passed type
 * any other value than 'fixed' is assumed as fluid
 */
.grid-create(@type, @fixed-width, @fixed-gutter, @cols) {
	// fluid grid (default)
	@width: 100%;

	// fluid gutter is calculated relatively to the static gutter in fixed grid width
	@gutter: round(percentage((100 / (@fixed-width / @fixed-gutter)) / 100), @decimal-places);

	// calculate the width of one grid column
	@one-col: (@width - (@gutter * (@cols))) / @cols;

	// implement grid mixins with type dependent variables
	#grid > .grid-mixins(@width, @gutter, @one-col);
}

.grid-create('fixed', @fixed-width, @fixed-gutter, @cols) {
	// fixed grid
	@width: @fixed-width;
	@gutter: @fixed-gutter;

	// calculate the width of one grid column
	@one-col: (@width - (@gutter * (@cols))) / @cols;

	// implement grid mixins with type dependent variables
	#grid > .grid-mixins(@width, @gutter, @one-col);
}

#grid {
	/*
	 * pass grid variables from global scope (defined on top)
	 * to our switch mixin which manipulates/creates variables
	 * this mixin is also our unlocker to use #grid > .mixins() as usual
	 */
	.grid-create(@grid-type, @grid-fixed-width, @grid-fixed-gutter, @grid-max-cols);

	// grid mixins which get called with manipulated variables from unlocker
	.grid-mixins(@width, @gutter, @one-col) {
		.span-width(@num) {
			width: round((@one-col * @num) + (@gutter * (@num - 1)), @decimal-places);
		}

		// indent grid columns either way with these mixins
		.indent(@num: 0) when (@num >= 0) {
			margin-left: round((@one-col * @num) + (@gutter * (@num + 1)), @decimal-places);
		}

		.indent(@num: -1) when (@num < 0) {
			margin-left: round((@one-col * @num) + (@gutter * (@num - 1)), @decimal-places);
		}

		// used only on .row for proper negative indent
		.row-indent(@num: 0) {
			margin-left: -(round((@one-col * @num) + (@gutter * (@num + 1)), @decimal-places));
		}

		// visually manipulate grid column order with these mixins
		.push(@num) when (@num >= 0) {
			position: relative;
			left: round((@one-col * @num) + (@gutter * @num), @decimal-places);
		}

		.pull(@num) when (@num >= 0) {
			position: relative;
			right: round((@one-col * @num) + (@gutter * @num), @decimal-places);
		}
	}

	// less loop
	.loop (@index, @class: item, @mixin: '') when (@index > 0) {
		// create the actual css selector
		.@{class}-@{index} {
			#loop-mixin > .apply(@mixin, @index);
		}

		// next iteration
		.loop(@index - 1, @class, @mixin);
	}

	// end the loop when index is 0
	.loop (@index) when (@index = 0) {
	}
}

/*
 * mixins to call inside less loop
 * use standardized global mixins - because we have them...
 */
#loop-mixin {
	// base grid loops
	.apply('grid-span', @index) {
		.col-span(@index);
	}

	.apply('grid-offset', @index) {
		.offset(@index);
	}

	.apply('grid-push', @index) {
		.push(@index);
	}

	.apply('grid-pull', @index) {
		.pull(@index);
	}
	// grid loops end
}

/*
 * make simpler global mixins available
 * (mainly for class/mixin name consistency)
 * values will depend on grid type
 * (either percent or pixel)
 */
.col-span(@num: 0) when (@num >= 0) {
	#grid > .span-width(@num);
}

.offset(@num: 0) {
	#grid > .indent(@num);
}

.push(@num: 0) when (@num >= 0) {
	#grid > .push(@num);
}

.pull(@num: 0) when (@num >= 0) {
	#grid > .pull(@num);
}

/*
* Clearfix: contain floats
*
* For modern browsers
* 1. The space content is one way to avoid an Opera bug when the
* `contenteditable` attribute is included anywhere else in the document.
* Otherwise it causes space to appear at the top and bottom of elements
* that receive the `clearfix` class.
* 2. The use of `table` rather than `block` is only necessary if using
* `:before` to contain the top-margins of child elements.
*/

.clearfix() {
	/*
	* For IE 6/7 only
	* Include this rule to trigger hasLayout and contain floats.
	*/
	*zoom: 1;

	&:before,
	&:after {
		content: " "; /* 1 */
		display: table; /* 2 */
	}

	&:after {
		clear: both;
	}
}

/*--- base grid layout styles ---*/
.row,
.col {
	display: block;
	margin-right: 0;
	padding-left: 0;
	padding-right: 0;
}

.row {
	.clearfix();
	// one gutter negative indent for row
	#grid > .row-indent(0);

	// used to .push and .pull columns
	&.ordered {
		position: relative;
	}
}

.col {
	// one gutter indent for each column
	#grid > .indent(0);
	float: left;

	/*
	 * spacer class for the rare occasion we have an "empty" column in a responsive grid layout
	 * where the use of .offset is not possible because of realignment of columns
	 */
	&.spacer {
		min-height: 1px;
	}
}

/*--- generate grid classes ---*/
/**
 * .loop() in helpers.less
 * 
 * Parameters:
 * 1) amount of iterations
 * 2) class selector prefix to generate
 * 3) mixin to apply to each selector
 *
 * mixins to apply can be found in loopmixins.less
 
 * Example:
 * .loop(12, item, 'setTabIndex');
 *
 * NOTE: you can not use the generated classes themselves as mixins!
 */

.row {
	#grid > .loop(@grid-max-cols, col-span, 'grid-span');
	#grid > .loop(@grid-max-cols - 1, offset, 'grid-offset');
	#grid > .loop(@grid-max-cols - 1, push, 'grid-push');
	#grid > .loop(@grid-max-cols - 1, pull, 'grid-pull');
}